今日二刷十五题:
1. 在排序数组中查找元素的第一个和最后一个位置
   1. 二分法先查询出其中一个索引，然后双指针分别向两边扩散到不等于该元素的位置
2. 组合总和 （先排序，然后回溯，由于元素可以重复，第二层不用start+1,但是防止往前查询，每一个回溯只能用自己和往后的元素，所以传递i进下一次回溯）
3. 接雨水 
   1. 单调栈，递增队列，栈顶到栈底是呈现递增状态
   2. 计算公式 area=(i-left-1)*(min(height[i],height[left])-height[mid])
4. 全排列（回溯，由于元素不能重复，这里回溯时需要 start+1）
5. 旋转图像（先进行上下翻转，在对角线翻转）
6. 字母异位词分组（都是英文字母，这里直接用数组当key）
7. 最大子数组合（由于是要求连续的，这里可以通过前缀和的方式求解，比较前缀和当前值，取最大值往后累计即可）
8. 跳跃游戏（计算每一步的索引+步数的最大值，如果能够覆盖到终点则返回true）
   1. 这里要注意，并不能遍历到每个索引，只能遍历步数覆盖的索引，类似贪心算法的意思
9. 合并区间（先排序，然后一一合并，判断当前的start是否大于前一个的end,大于则不用合并，小于的话则需要取两者end大的合并） 
10. 不同路径（动态规划，这里要注意初始值的初始化，dp[i][0]=1,dp[0][j]=1）
11. 最小路径和（动态规划，这里要注意初始值的初始化，dp[i][0]=dp[i-1][0]+nums[i][0],dp[0][j]=dp[0][j-1]+nums[0][j]）
12. 爬楼梯（dp[i]=dp[i-1]+dp[i-2],也可以申明一个长度为2的数组覆盖写）
13. 编辑距离(动态规划,这里要注意初始值的初始化，dp[i][0]=i,dp[0][j]=j)
    1. 两个字符串相等 dp[i][j] = dp[i-1][j-1]
    2. 两个字符串不相等，则有两个情况
       1. 替换： dp[i][j] = dp[i-1][j-1]+1
       2. 删除：dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1) 可以任意删除其中一个字符
       3. 新增：新增一个字符实际上就是删除另一个字符，这里一样，无需处理
14. 颜色分类（双指针，p0/p1分别指向下一个0/1即将填充的位置，交换0之后还需要考虑是否需要和1的位置进行交换）
15. 最小覆盖子串（滑动窗口，先用map计数将要检索的数据量,然后移动左右指针，寻找可以覆盖子串的最小值即可）





升序排序：
```golang
sort.Slice(arr,func(i,j int)bool{
	return arr[i]<arr[j]
})

```