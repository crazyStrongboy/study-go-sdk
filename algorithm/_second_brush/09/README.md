今日二刷十一题：
1. 找到数组中消失的数字
   1. 计算出该数字本身应该出现的索引位置index=(nums[i]+n-1)%n
   2. 将index处位置累加n
   3. 遍历数组，找到所有位置小于等于n的索引，即是消失的数字
2. 汉明距离(两个数异或后二进制中1的数量即为答案)
3. 目标和(计算出数组的累加和sum，(sum+target)/2即是需要凑齐的数)
   1. sum不能大于target绝对值，若大于，返回0，表示凑不齐
   2. 凑齐的数为负数时，需要先转换成正数，在用完全背包方式去解题
   3. dp[0]要初始化为1，表示只有一种方法去凑0的背包
4. 把二叉搜索树转换成累加树(反中序遍历方式，用pre记住上一个和即可)
5. 二叉树的直径(分别取depth(root.left),depth(root.right)最大值，再进行计算)
6. 和为k的子数组
   1. 第一种方式：暴力破解，两层for循环
   2. 第二种方式：前缀+map形式，注意map里面存的前缀累计count，不能是1
7. 最短无序连续子数组
   1. 第一种方式：拷贝一个出来进行排序，然后两个数组分别从首尾像中间推进，第一个不相等的即为left和right，
      注意边界处理，从左边开始，如果一个不相等的都找不到，则返回最大值
   2. 第二种方式：
      1. max=math.MinInt32,从左边开始往右边找,如果小于max则right = i,大于则max=nums[i] (保证right之后都不小于right)
      2. min=math.MaxInt32,从右边往左边找,如果大于min，则left = i,小于则min=nums[i] (保证left之前都不大于left)
      3. 计算right-left即可(这里可以保证[0:left] [left:right] [right:]三段是递增的关系)
8. 合并二叉树（递归累加即可）
9. 任务调度器（计算出最大任务数maxCount，然后统计最大任务数个数sub，那么最大消耗即为(maxCount-1)*(n+1)+sub,这里还需要和本身长度进行对比）
10. 每日温度（使用栈，存储温度的索引,遇见nums[i]>nums[stack[top]]即弹栈，计算i-top即可）
11. 回文子串（递归，这里注意可以分别从i,和(i，i+1)向两边扩散）