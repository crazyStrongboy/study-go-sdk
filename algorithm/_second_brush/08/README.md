今日二刷七题:
1. 比特位计数
   1. 最简单的办法是累计i=i&(i-1),直到i为0，就知道有多少个1
   2. 第二个办法nums[i>>1]+i&1,去掉最低位，看有多少个1，然后加上末尾是否为1
   3. 第三个办法nums[i&(i-1)]+1,去掉最高位，直接补上1
2. 前k个高频元素（最简单的办法是用个二维数组进行排序，这样时间复杂度和空间复杂度都比较高）
   1. 先用map搜集出所有的元素的数量
   2. 利用最小堆的原理永远只保留三个元素
3. 字符串解码
   1. 两个栈，一个放数字，一个放"["之前的字符串，遇到"]"则进行弹栈，两个栈都需要弹出来
   2. 字符栈弹出来当前缀，当前累计的tmp []byte当重复量，pre+=n*tmp,最后tmp=pre
   3. 数字进栈时需要注意合并，即n=n*10+num[i]
4. 根据身高重建队列
   1. 按身高从高到矮排序，身高相同则排序高的在前面
   2. 然后遍历，分别取对应的排序p[1]插在数组p[1]位置，注意copy原数组腾位置
5. 分隔等和子集
   1. 背包原理，这里要求字符是不能重复选的，所以背包在内循环必须从大到小遍历
6. 路径总和
   1. 两轮遍历，因为每个节点都可以当路径的根节点
   2. 计算时注意只能往下，所以分别用target减去左右节点的值往下传递，互不干扰
7. 找到字符串所有字母异位词(这种题思路很清晰，写的时候需要特别注意，一步步来即可)
   1. 先将需要找的字符串用map装起来,申明needCount=len(map)
   2. 滑动窗口，右指针先往右走k步，命中map里面的key则减去1，当map对应key值为0时needCount--
   3. 这里可以先判断一次是否满足needCount==0，满足则取i填入result
   4. 然后左指针和右指针一起向右滑动，参考步骤2的操作,元素出了窗口，命中map里面的key则加上1，needCount++
   5. needCount==0,则取i+1填入result