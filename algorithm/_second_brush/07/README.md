今日二刷十六题:
1. 反转二叉树（前序递归root.Left,root.Right=root.Right,root.Left）
2. 回文链表
   1. 只遍历一次，需要使用快慢指针，fast遍历到尾部，slow正好在终点位置
   2. 反转slow之后的列表
   3. 然后slow与head一起取next,遍历到结束都相等则为回文链表
3. 二叉树最近公共祖先（后序遍历，主要注意几个边界问题）
   1. root为空或者p或者q，直接返回root
   2. root.Left 和 root.Right 不为空,则返回root
   3. left 和 right 任意一个不为空，则返回不为空的那个
4. 除自身以外数组的乘积
   1. 分别从前和从后计算出前缀乘积pre和后缀乘积suffix
   2. result[i] = pre[i]*suffix[i]
5. 滑动窗口最大值(使用栈去处理这个问题，主要处理一个边界，当遍历到下一个窗口的时候需要清理掉上一个窗口的数据，也就是栈底的数据)
6. 搜索二维矩阵2(i从大到小，j从小到大遍历，如果target<matrix[i][j],则i--,反之j++)
7. 完全平方数(动态规划，求dp[i] =min(dp[i-j*j]+1,dp[i]))
8. 移动零(使用count记录不为0的数目，不为0的交换到count位置处，count++，然后从count+1往后全部置为0)
9. 寻找重复数(将数组看成链表，然后快慢指针去解决这个问题，slow=nums[slow],fast=nums[nums[fast]])
10. 二叉树序列化和反序列化(层序遍历)
11. 最长递增子序列(动态规划，如果nums[i]>nums[j],那么dp[i]=max(dp[i],dp[j]+1))
12. 删除无效的括号(贪心算法,先考虑全长字符串，满足添加结果返回,不满足分别从头到尾去掉一个是括号的字符串，满足则添加结果返回,不满足继续删字符串)
13. 最近买卖股票含冷冻期(动态规划，dp[0][0]=-prices[0])
    1. 这里针对股票有三个状态(0:买入 1:卖出  2:冷冻期),那么会出现一下几个公式
    2. dp[i][0]=max(dp[i-1][2]-prices[i],dp[i][0]) 要么前一天就是买入状态，要么前一天是冷冻期,需要扣除买股票的钱
    3. dp[i][1]=max(dp[i-1][0],dp[i][1]) 要么前一天买入，要么前一天是持有状态
    4. dp[i][2]=dp[i-1][1] 前一天必须是冷冻期
14. 戳气球(这里把问题转换成添加气球,这样可以保证两边的值都是已有的)
    1. 具体公式 dp[i][j]=max(dp[i][j],dp[i][k]+nums[i]*nums[k]*nums[j]+dp[k][j])
    2. 这里需要给nums首尾都需要添加一个1，题意也表明边界都是乘以1的，所以可以在入口就直接补上去
    3. 这里遍历时要注意：i从最大值开始遍历,n-3，j从i+2处遍历,也就是n-1，k从i+1处遍历,也就是n-2,k必须要在i和j中间
15. 零钱兑换(动态规划，如果i>coins[j],那么dp[i]=min(dp[i],dp[i-coins[j]]+1))
    1. 注意点，除了dp[0],其他值需要初始化为题目限定的最大值
    2. 返回结果前需要判断是否和初始值一致，要区分出是否能够凑满零钱
16. 打家劫舍3(动态规划)
    1. 每个节点用数组去记录两个数据[打劫当前节点的最大值,不打劫当前节点的最大值]，分别用0，1表示
    2. 当打劫当前节点时，val=root.val+left[1]+right[1]
    3. 当不打劫当前节点时，val=max(left[0],left[1])+max(right[0],right[1]),这里注意因为不打劫当前节点，
       那就可以选择最大值，不一定必须选择left和right,也可以选择他们的子节点。